<!--
AR Floor Placer — Single-file HTML
Works on WebXR-enabled browsers (Chrome on Android with WebXR & AR Module).
Fallback to non-AR desktop mode (click on ground plane to place and drag to move).
Features:
 - Choose shape (Cube, Sphere, Cone)
 - Place object on floor using AR hit-test (or click on desktop)
 - Tap/Click and drag objects to move them
 - Long-press or press Delete button to remove selected object
 - Simple UI overlay

Notes: For full AR experience, use a device with WebXR AR support and secure context (https).
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AR Floor Placer</title>
  <style>
    html,body{height:100%;margin:0}
    #ui{
      position:fixed;left:12px;top:12px;z-index:5;backdrop-filter: blur(6px);background:rgba(255,255,255,0.85);padding:8px;border-radius:8px;font-family:system-ui,Arial}
    #ui select, #ui button{margin:6px 4px;padding:8px;border-radius:6px;border:1px solid #ccc}
    #message{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:8px;font-family:system-ui;z-index:5}
    #enterAR{display:block;margin-top:6px}
    #canvasHolder{width:100%;height:100%;touch-action:none}
    .hint{font-size:12px;color:#333}
  </style>
</head>
<body>
  <div id="ui">
    <div>
      <label class="hint">Shape:</label>
      <select id="shapeSel">
        <option value="box">Cube</option>
        <option value="sphere">Sphere</option>
        <option value="cone">Cone</option>
      </select>
      <button id="placeBtn">Place</button>
      <button id="deleteBtn">Delete Selected</button>
    </div>
    <div>
      <label class="hint">Scale:</label>
      <input id="scaleRange" type="range" min="0.1" max="3" step="0.05" value="1">
    </div>
    <div>
      <button id="clearBtn">Clear All</button>
      <button id="helpBtn">Help</button>
    </div>
    <button id="enterAR">Enter AR</button>
  </div>

  <div id="canvasHolder"></div>
  <div id="message">Tap 'Enter AR' to try WebXR AR or use 'Place' to put objects (desktop fallback available).</div>

  <!-- three.js and supporting libs -->
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.150.1/examples/jsm/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js"></script>

  <script>
  // Basic scene + AR setup
  let camera, scene, renderer;
  let controller; // XR controller for input
  let reticle; // placement reticle
  let hitTestSource = null;
  let hitTestSourceRequested = false;

  const objects = [];
  let selected = null;

  const container = document.getElementById('canvasHolder');

  init();
  animate();

  function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    container.appendChild(renderer.domElement);

    // light
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // ground (invisible helper for non-AR)
    const grid = new THREE.GridHelper(10,10,0x444444,0x888888);
    grid.position.y = 0;
    grid.visible = true;
    scene.add(grid);

    // reticle for AR placement
    reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.08, 0.12, 32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({color:0x00ff00})
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // controller for taps
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect); // XR tap
    scene.add(controller);

    // non-XR pointer interactions
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);

    window.addEventListener('resize', onWindowResize);

    // AR Button
    const arButton = ARButton.createButton(renderer, {requiredFeatures:['hit-test']});
    document.getElementById('enterAR').replaceWith(arButton);

    // UI
    document.getElementById('placeBtn').addEventListener('click', ()=>{ placeAtCenter(); });
    document.getElementById('deleteBtn').addEventListener('click', deleteSelected);
    document.getElementById('clearBtn').addEventListener('click', clearAll);
    document.getElementById('helpBtn').addEventListener('click', showHelp);
    document.getElementById('scaleRange').addEventListener('input', (e)=>{ if(selected) selected.scale.setScalar(e.target.value); });

    // Orbit controls only for non-XR preview
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(0,1.6,3);
    controls.target.set(0,0,0);
    controls.update();

    // small instruction
    setMessage('Ready — choose a shape and press Place, or enter AR and tap to place.');
  }

  function createShape(type){
    let geom;
    switch(type){
      case 'sphere': geom = new THREE.SphereGeometry(0.25,32,32); break;
      case 'cone': geom = new THREE.ConeGeometry(0.25,0.5,32); break;
      default: geom = new THREE.BoxGeometry(0.5,0.5,0.5);
    }
    const mat = new THREE.MeshStandardMaterial({color: Math.random()*0xffffff, roughness:0.6, metalness:0.2});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.userData.draggable = true;
    return mesh;
  }

  // Place at center of camera view (non-XR or when reticle hidden)
  function placeAtCenter(){
    const shape = document.getElementById('shapeSel').value;
    const mesh = createShape(shape);
    // try to place where reticle is visible (AR)
    if(reticle.visible){
      mesh.position.setFromMatrixPosition(reticle.matrix);
    } else {
      // raycast from camera to ground plane y=0
      const dir = new THREE.Vector3(0,0,-1).transformDirection(camera.matrixWorld);
      const origin = camera.position.clone();
      const t = (0 - origin.y) / dir.y;
      const pos = origin.clone().add(dir.multiplyScalar(t));
      mesh.position.copy(pos);
    }
    scene.add(mesh);
    objects.push(mesh);
    selectObject(mesh);
  }

  function onSelect(){
    // Called by XR tap: place at reticle
    if(reticle.visible){
      const shape = document.getElementById('shapeSel').value;
      const mesh = createShape(shape);
      mesh.position.setFromMatrixPosition(reticle.matrix);
      scene.add(mesh);
      objects.push(mesh);
      selectObject(mesh);
    }
  }

  // Pointer drag to move objects (desktop and AR)
  let isPointerDown = false;
  let dragObject = null;
  let pointerId = null;

  function onPointerDown(event){
    isPointerDown = true;
    pointerId = event.pointerId;
    const x = (event.clientX / window.innerWidth) * 2 - 1;
    const y = - (event.clientY / window.innerHeight) * 2 + 1;
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera({x,y}, camera);
    const intersects = raycaster.intersectObjects(objects, true);
    if(intersects.length>0){
      dragObject = intersects[0].object;
      selectObject(dragObject);
    } else {
      // place new if not clicked on object
      // optionally create
    }
  }

  function onPointerMove(event){
    if(!isPointerDown || !dragObject) return;
    // compute a ground hit or AR hit-test if in XR
    if(renderer.xr.isPresenting){
      // try to use hit-test at pointer location - but WebXR hit-test with transient input is complex
      // We'll approximate by casting a ray from camera through screen and intersecting a horizontal plane y=dragObject.position.y
      const planeY = dragObject.position.y;
      const x = (event.clientX / window.innerWidth) * 2 - 1;
      const y = - (event.clientY / window.innerHeight) * 2 + 1;
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera({x,y}, camera);
      const dir = raycaster.ray.direction;
      const origin = raycaster.ray.origin;
      const t = (planeY - origin.y) / dir.y;
      if(isFinite(t)){
        const newPos = origin.clone().add(dir.multiplyScalar(t));
        dragObject.position.copy(newPos);
      }
    } else {
      // desktop: intersect with plane y=0
      const planeY = 0.0;
      const x = (event.clientX / window.innerWidth) * 2 - 1;
      const y = - (event.clientY / window.innerHeight) * 2 + 1;
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera({x,y}, camera);
      const dir = raycaster.ray.direction;
      const origin = raycaster.ray.origin;
      const t = (planeY - origin.y) / dir.y;
      if(isFinite(t)){
        const newPos = origin.clone().add(dir.multiplyScalar(t));
        dragObject.position.copy(newPos);
      }
    }
  }

  function onPointerUp(event){
    isPointerDown = false;
    dragObject = null;
  }

  function selectObject(obj){
    if(selected) selected.material.emissive && (selected.material.emissive.setHex(0x000000));
    selected = obj;
    if(selected.material && selected.material.emissive) selected.material.emissive.setHex(0x333333);
    document.getElementById('scaleRange').value = selected.scale.x;
  }

  function deleteSelected(){
    if(!selected) return setMessage('No object selected');
    scene.remove(selected);
    const idx = objects.indexOf(selected);
    if(idx!==-1) objects.splice(idx,1);
    selected = null;
    setMessage('Selected object deleted');
  }

  function clearAll(){
    objects.forEach(o=> scene.remove(o));
    objects.length = 0;
    selected = null;
    setMessage('All objects removed');
  }

  function showHelp(){
    alert('Instructions:\n- Enter AR and tap the screen to place shapes on the floor (requires WebXR hit-test).\n- On desktop, use Place to drop at camera center.\n- Click/tap an object and drag to move it.\n- Use Scale slider to resize selected object.\n- Delete Selected or Clear All to remove objects.');
  }

  function setMessage(text, time=3000){
    const el = document.getElementById('message');
    el.textContent = text;
    if(time>0){
      clearTimeout(el._t);
      el._t = setTimeout(()=>{ el.textContent = ''; }, time);
    }
  }

  // XR animation loop + hit-test handling
  function animate(){
    renderer.setAnimationLoop(render);
  }

  function render(timestamp, frame){
    if(frame){
      const session = renderer.xr.getSession();
      if(hitTestSourceRequested === false){
        session.requestReferenceSpace('viewer').then(function(refSpace){
          session.requestHitTestSource({space: refSpace}).then(function(source){
            hitTestSource = source;
          });
        });

        session.addEventListener('end', function(){
          hitTestSourceRequested = false;
          hitTestSource = null;
        });

        hitTestSourceRequested = true;
      }

      if(hitTestSource){
        const referenceSpace = renderer.xr.getReferenceSpace();
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if(hitTestResults.length){
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }
    }

    renderer.render(scene, camera);
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  </script>
</body>
</html>
