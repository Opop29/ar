<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Geo AR ‚Äî Supabase Locations (Floating Cubes)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- A-Frame and AR.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.5/aframe/build/aframe-ar.js"></script>

  <style>
    html, body { margin:0; padding:0; background:#000; color:#fff; font-family: system-ui, Arial, sans-serif; }
    #hud {
      position: fixed; left: 0; right: 0; top: 0;
      display: flex; gap: 8px; align-items: center; padding: 10px;
      background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
      z-index: 10;
    }
    #hud .pill {
      background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.2);
      padding: 8px 12px; border-radius: 999px; backdrop-filter: blur(6px);
      font-weight: 600; color: #fff; cursor: pointer;
    }
    #msg { margin-left: auto; opacity: .9; font-size: 14px; }
    #arrow {
      position: fixed; bottom: 50%; left: 50%; transform: translate(-50%, 0);
      font-size: 48px; opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill" onclick="goBack()">‚¨Ö Back</div>
    <div class="pill" id="status">Requesting camera + GPS‚Ä¶</div>
    <div id="msg"></div>
  </div>

  <!-- Arrow cue -->
  <div id="arrow">‚¨ÜÔ∏è</div>

  <a-scene
    vr-mode-ui="enabled: false"
    renderer="antialias: true; alpha: true; physicallyCorrectLights: true"
    embedded
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false; trackingMethod: best;"
    device-orientation-permission-ui="enabled: false"
  >
    <a-entity id="camera" camera gps-camera rotation-reader></a-entity>

    <!-- Lighting -->
    <a-entity light="type: directional; intensity: 0.9" position="0 10 0"></a-entity>
    <a-entity light="type: ambient; intensity: 0.6"></a-entity>
  </a-scene>

  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    const supabase = createClient(
      "https://clywxultbpgqlqlorjjh.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNseXd4dWx0YnBncWxxbG9yampoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMjAzNzUsImV4cCI6MjA3MTY5NjM3NX0.nAAU2oT9-hy7tekZGsVwNMKzTzZSRCvJWjBEiba8F3U"
    );

    const statusEl = document.getElementById('status');
    const msgEl = document.getElementById('msg');
    const arrowEl = document.getElementById('arrow');
    const scene = document.querySelector('a-scene');

    window.goBack = () => (window.location.href = "home.html");

    // Haversine + bearing
    function toRad(d){return d*Math.PI/180;}
    function distanceMeters(lat1, lon1, lat2, lon2){
      const R=6371000;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2+Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }
    function bearingDeg(lat1, lon1, lat2, lon2){
      const y = Math.sin(toRad(lon2-lon1)) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1))*Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1))*Math.cos(toRad(lat2))*Math.cos(toRad(lon2-lon1));
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    function createCube(loc){
      const group = document.createElement('a-entity');
      group.setAttribute('gps-entity-place', `latitude: ${loc.latitude}; longitude: ${loc.longitude};`);

      // Cube ~ human chest level
      const cube = document.createElement('a-box');
      cube.setAttribute('depth', 0.5);
      cube.setAttribute('height', 0.5);
      cube.setAttribute('width', 0.5);
      cube.setAttribute('position', '0 1.6 0'); // 1.6 m eye level
      cube.setAttribute('material', 'color: #4CAF50; metalness:0.2; roughness:0.6');

      // Label text
      const label = document.createElement('a-entity');
      label.setAttribute('text', `value:${loc.name}; align:center; width:4; color:#fff;`);
      label.setAttribute('position', '0 2.3 0');

      // Touch interaction
      cube.addEventListener('click', () => {
        msgEl.textContent = `üìç ${loc.name}`;
        setTimeout(() => { msgEl.textContent = ''; }, 2500);
      });

      group.appendChild(cube);
      group.appendChild(label);
      return group;
    }

    async function loadLocations(){
      statusEl.textContent = 'Loading locations‚Ä¶';
      const { data, error } = await supabase.from('locations').select('*').order('id');
      if(error){ statusEl.textContent = 'Load failed'; return []; }
      statusEl.textContent = `Loaded ${data.length} location(s)`;
      return data;
    }

    function startGuidance(locations){
      let last={lat:null, lon:null};
      window.addEventListener('gps-camera-update-position',(e)=>{
        const pos=e.detail.position;
        if(!pos||pos.latitude==null) return;
        const {latitude:lat, longitude:lon, accuracy}=pos;
        if(lat===last.lat&&lon===last.lon) return;
        last={lat,lon};

        if(locations.length){
          let nearest={loc:null, dist:Infinity};
          for(const l of locations){
            const d=distanceMeters(lat,lon,l.latitude,l.longitude);
            if(d<nearest.dist) nearest={loc:l,dist:d};
          }
          statusEl.textContent=`GPS ¬±${Math.round(accuracy||10)} m ¬∑ Nearest: ${nearest.loc.name} ‚Äî ${nearest.dist.toFixed(0)} m`;

          // Compute bearing to nearest & show arrow
          const b=bearingDeg(lat,lon,nearest.loc.latitude,nearest.loc.longitude);
          const deviceHeading=window.lastHeading||0;
          const rel=(b-deviceHeading+360)%360;
          // Rotate arrow according to relative bearing
          arrowEl.style.transform=`translate(-50%,0) rotate(${rel}deg)`;
        }
      });
    }

    // Track device orientation heading
    window.lastHeading=0;
    window.addEventListener("deviceorientationabsolute", e=>{
      if(e.alpha!=null) window.lastHeading=e.alpha;
    }, true);
    window.addEventListener("deviceorientation", e=>{
      if(e.webkitCompassHeading) window.lastHeading=e.webkitCompassHeading;
    }, true);

    (async function init(){
      const locs=await loadLocations();
      for(const l of locs) scene.appendChild(createCube(l));
      startGuidance(locs);
      msgEl.textContent="Move phone to let GPS lock and follow arrow.";
      setTimeout(()=>msgEl.textContent='',4000);
    })();
  </script>
</body>
</html>
